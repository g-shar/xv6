diff --git a/Makefile b/Makefile
index 09d790c..c201cb5 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,9 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test\
+	_test2\
+	_test3\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +220,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
diff --git a/defs.h b/defs.h
index 82fb982..9d513c7 100644
--- a/defs.h
+++ b/defs.h
@@ -118,6 +118,7 @@ void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
+int             set_prior(int);
 void            wakeup(void*);
 void            yield(void);
 
diff --git a/exec.c b/exec.c
index b40134f..ed59469 100644
--- a/exec.c
+++ b/exec.c
@@ -93,6 +93,12 @@ exec(char *path, char **argv)
       last = s+1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
  
+  acquire(&tickslock);
+  curproc->start_time = ticks;
+  curproc->prevTicks = ticks;
+  release(&tickslock);
+  curproc->burst_time = 0;
+
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
diff --git a/init.c b/init.c
index 046b551..137d982 100644
--- a/init.c
+++ b/init.c
@@ -32,6 +32,6 @@ main(void)
       exit();
     }
     while((wpid=wait()) >= 0 && wpid != pid)
-      printf(1, "zombie!\n");
+      printf(1, "zombie for process %d!\n", wpid);
   }
 }
diff --git a/proc.c b/proc.c
index 806b1b1..38db310 100644
--- a/proc.c
+++ b/proc.c
@@ -77,7 +77,6 @@ allocproc(void)
   char *sp;
 
   acquire(&ptable.lock);
-
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)  
     if(p->state == UNUSED)
       goto found;
@@ -88,7 +87,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
-
+  p->prior_val = 31;   // Default to lowest priority
   release(&ptable.lock);
 
   // Allocate kernel stack.
@@ -199,7 +198,7 @@ fork(void)
   np->sz = curproc->sz;
   np->parent = curproc;
   *np->tf = *curproc->tf;
-
+  np->prior_val = curproc->prior_val;   // Set child prior_val to parent's
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
@@ -221,6 +220,18 @@ fork(void)
   return pid;
 }
 
+int
+set_prior(int prior_lvl){
+    struct proc *curproc = myproc();
+    if (prior_lvl >= 0 && prior_lvl <32){
+        curproc->prior_val = prior_lvl;
+    }else{
+        curproc->prior_val = 31;
+    }
+    yield();    // transfer control to scheduler immediately
+    return prior_lvl;
+}
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
@@ -262,6 +273,16 @@ exit(void)
   }
 
   // Jump into the scheduler, never to return.
+  acquire(&tickslock);
+  curproc->turnaround_time = ticks - curproc->start_time;
+  release(&tickslock);
+  curproc->waiting_time = curproc->turnaround_time - curproc->burst_time;
+  cprintf("Process name: %s\n", curproc->name);
+  cprintf("pid: %d\n", curproc->pid);
+  cprintf("Priority: %d\n", curproc->prior_val);
+  cprintf("Turnaround time: %d\n", curproc->turnaround_time);
+  cprintf("Waiting time: %d\n", curproc->waiting_time);
+  cprintf("\n");
   curproc->state = ZOMBIE;
   sched();
   panic("zombie exit");
@@ -325,33 +346,56 @@ scheduler(void)
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
   for(;;){
     // Enable interrupts on this processor.
     sti();
-
-    // Loop over process table looking for process to run.
+    int highestPVal = 31;
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      // find the highest priority value in the processes
       if(p->state != RUNNABLE)
           continue;
+      if (p->prior_val < highestPVal){
+	  highestPVal = p->prior_val;
+      }
+    }
 
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+        if (p->prior_val == highestPVal){
+          if (p->prior_val < 31){
+              p->prior_val++;
+          }else{
+              p->prior_val = 31;
+          }
           // Switch to chosen process.  It is the process's job
           // to release ptable.lock and then reacquire it
           // before jumping back to us.
           c->proc = p;
           switchuvm(p);
           p->state = RUNNING;
-
+          acquire(&tickslock);
+	  if (ticks > p->prevTicks) {
+	      p->burst_time += 1;
+              p->prevTicks = ticks;
+	  }
+          release(&tickslock);
           swtch(&(c->scheduler), p->context);
           switchkvm();
 
           // Process is done running for now.
           // It should have changed its p->state before coming back.
           c->proc = 0;
+      } else {
+          if (p->prior_val > 0){
+              p->prior_val--;
+          } else {
+              p->prior_val = 0;
+          }
+      }
     }
     release(&ptable.lock);
-
   }
 }
 
diff --git a/proc.h b/proc.h
index 1647114..f946be5 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,12 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int prior_val;               // Process priority value
+  uint turnaround_time;	       // Process turnaround time
+  uint start_time; 	       // Process start time
+  uint burst_time;	       // Process burst time
+  uint waiting_time;           // Process waiting time
+  uint prevTicks;              // Prrevious ticks for burst time
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..5e3aeb0 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_set_prior(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_set_prior] sys_set_prior,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..c00fdef 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_set_prior 22
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..609abed 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -27,6 +27,17 @@ sys_wait(void)
 }
 
 int
+sys_set_prior(void)
+{
+    int prior_lvl;
+    if (argint(0, &prior_lvl) < 0){
+        return -1;
+    }else{
+        return set_prior(prior_lvl);
+    }
+}
+
+int
 sys_kill(void)
 {
   int pid;
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..2b7313f
--- /dev/null
+++ b/test.c
@@ -0,0 +1,16 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char** argv){
+    set_prior(1);
+    int i, k;
+    for (i = 0; i < 43000; i++){
+        asm("nop");
+        for (k = 0; k < 43000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
+
diff --git a/test2.c b/test2.c
new file mode 100644
index 0000000..4300a78
--- /dev/null
+++ b/test2.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char** argv){
+    set_prior(3);
+    int i, k;
+    for (i = 0; i < 60000; i++){
+        asm("nop");
+        for (k = 0; k < 60000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
diff --git a/test3.c b/test3.c
new file mode 100644
index 0000000..5f857cc
--- /dev/null
+++ b/test3.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(int argc, char** argv){
+    set_prior(5);
+    int i, k;
+    for (i = 0; i < 70000; i++){
+        asm("nop");
+        for (k = 0; k < 70000; k++){
+            asm("nop");
+        }
+    }
+    exit();
+}
diff --git a/user.h b/user.h
index 4f99c52..b9230f1 100644
--- a/user.h
+++ b/user.h
@@ -23,7 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
-
+int set_prior(int);
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..ebad0a5 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(set_prior)
\ No newline at end of file
